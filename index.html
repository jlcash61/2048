<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phaser 2048</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
  <script>
    // Initialize Phaser
    var config = {
      type: Phaser.AUTO,
      width: 400,
      height: 400,
      backgroundColor: '#bbada0',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    var game = new Phaser.Game(config);
    var grid;
    var tileSize = 100;
    var tileObjects = [];
    var swipeThreshold = 20; // Minimum distance for a swipe
    var startX, startY;

    function preload() {
      // Load any assets if needed
    }

    function create() {
      // Initialize the game grid
      grid = [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ];
      
      // Spawn initial tiles
      addTile();
      addTile();

      // Add input handlers
      this.input.keyboard.on('keydown', handleInput, this);
      this.input.on('pointerdown', startSwipe, this);
      this.input.on('pointerup', endSwipe, this);

      // Render the initial state
      drawGrid(this);
    }

    function update() {
      // Game loop logic if needed
    }

    function handleInput(event) {
      switch (event.code) {
        case 'ArrowUp':
          moveTiles(0);
          break;
        case 'ArrowDown':
          moveTiles(1);
          break;
        case 'ArrowLeft':
          moveTiles(2);
          break;
        case 'ArrowRight':
          moveTiles(3);
          break;
      }
    }

    function startSwipe(pointer) {
      startX = pointer.x;
      startY = pointer.y;
    }

    function endSwipe(pointer) {
      var endX = pointer.x;
      var endY = pointer.y;
      var diffX = endX - startX;
      var diffY = endY - startY;

      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (Math.abs(diffX) > swipeThreshold) {
          if (diffX > 0) {
            moveTiles(3); // Right
          } else {
            moveTiles(2); // Left
          }
        }
      } else {
        if (Math.abs(diffY) > swipeThreshold) {
          if (diffY > 0) {
            moveTiles(1); // Down
          } else {
            moveTiles(0); // Up
          }
        }
      }
    }

    function moveTiles(direction) {
      let moved = false;

      if (direction === 0) { // Up
        for (let col = 0; col < 4; col++) {
          for (let row = 1; row < 4; row++) {
            if (grid[row][col] !== 0) {
              let targetRow = row;
              while (targetRow > 0 && grid[targetRow - 1][col] === 0) {
                grid[targetRow - 1][col] = grid[targetRow][col];
                grid[targetRow][col] = 0;
                targetRow--;
                moved = true;
              }
              if (targetRow > 0 && grid[targetRow - 1][col] === grid[targetRow][col]) {
                grid[targetRow - 1][col] *= 2;
                grid[targetRow][col] = 0;
                moved = true;
              }
            }
          }
        }
      } else if (direction === 1) { // Down
        for (let col = 0; col < 4; col++) {
          for (let row = 2; row >= 0; row--) {
            if (grid[row][col] !== 0) {
              let targetRow = row;
              while (targetRow < 3 && grid[targetRow + 1][col] === 0) {
                grid[targetRow + 1][col] = grid[targetRow][col];
                grid[targetRow][col] = 0;
                targetRow++;
                moved = true;
              }
              if (targetRow < 3 && grid[targetRow + 1][col] === grid[targetRow][col]) {
                grid[targetRow + 1][col] *= 2;
                grid[targetRow][col] = 0;
                moved = true;
              }
            }
          }
        }
      } else if (direction === 2) { // Left
        for (let row = 0; row < 4; row++) {
          for (let col = 1; col < 4; col++) {
            if (grid[row][col] !== 0) {
              let targetCol = col;
              while (targetCol > 0 && grid[row][targetCol - 1] === 0) {
                grid[row][targetCol - 1] = grid[row][targetCol];
                grid[row][targetCol] = 0;
                targetCol--;
                moved = true;
              }
              if (targetCol > 0 && grid[row][targetCol - 1] === grid[row][targetCol]) {
                grid[row][targetCol - 1] *= 2;
                grid[row][targetCol] = 0;
                moved = true;
              }
            }
          }
        }
      } else if (direction === 3) { // Right
        for (let row = 0; row < 4; row++) {
          for (let col = 2; col >= 0; col--) {
            if (grid[row][col] !== 0) {
              let targetCol = col;
              while (targetCol < 3 && grid[row][targetCol + 1] === 0) {
                grid[row][targetCol + 1] = grid[row][targetCol];
                grid[row][targetCol] = 0;
                targetCol++;
                moved = true;
              }
              if (targetCol < 3 && grid[row][targetCol + 1] === grid[row][targetCol]) {
                grid[row][targetCol + 1] *= 2;
                grid[row][targetCol] = 0;
                moved = true;
              }
            }
          }
        }
      }

      if (moved) {
        addTile();
        drawGrid(game.scene.keys.default);
      }
    }

    function addTile() {
      let emptyTiles = [];
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          if (grid[row][col] === 0) {
            emptyTiles.push({ row: row, col: col });
          }
        }
      }
      if (emptyTiles.length > 0) {
        let newTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
        grid[newTile.row][newTile.col] = Math.random() < 0.9 ? 2 : 4;
      }
    }

    function drawGrid(scene) {
      // Remove previous tile objects
      tileObjects.forEach(tile => tile.destroy());
      tileObjects = [];

      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          let value = grid[row][col];
          let x = col * tileSize;
          let y = row * tileSize;
          let color = getColor(value);
          let tile = scene.add.rectangle(x + tileSize / 2, y + tileSize / 2, tileSize - 10, tileSize - 10, color).setStrokeStyle(2, 0x776e65);
          tileObjects.push(tile);
          if (value !== 0) {
            let text = scene.add.text(x + tileSize / 2, y + tileSize / 2, value, { fontSize: '32px', color: '#776e65' }).setOrigin(0.5);
            tileObjects.push(text);
          }
        }
      }
    }

    function getColor(value) {
      switch (value) {
        case 2: return 0xeee4da;
        case 4: return 0xede0c8;
        case 8: return 0xf2b179;
        case 16: return 0xf59563;
        case 32: return 0xf67c5f;
        case 64: return 0xf65e3b;
        case 128: return 0xedcf72;
        case 256: return 0xedcc61;
        case 512: return 0xedc850;
        case 1024: return 0xedc53f;
        case 2048: return 0xedc22e;
        default: return 0xcdc1b4;
      }
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phaser 2048</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f9f9f9;
    }
    .message, .continue-button, .reset-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #ffffff;
      background-color: #000000;
      padding: 10px 20px;
      cursor: pointer;
      display: none;
    }
    .message {
      font-size: 48px;
      top: 40%;
    }
  </style>
</head>
<body>
  <div id="continueButton" class="continue-button">Continue</div>
  <div id="resetButton" class="reset-button">Reset</div>
  <div id="message" class="message"></div>
  <script>
    // Initialize Phaser
    var config = {
      type: Phaser.AUTO,
      width: 400,
      height: 500, // Increased height for title and score
      backgroundColor: '#bbada0',
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
      }
    };

    var game = new Phaser.Game(config);
    var grid;
    var tileSize = 100;
    var tileObjects = [];
    var score = 0;
    var scoreText;
    var puppyThresholds = [512, 1024];
    var currentPuppyThreshold = 0;
    var startX, startY;
    var swipeThreshold = 50; // Minimum distance for a swipe
    var puppyImage;
    var continueButton = document.getElementById('continueButton');
    var resetButton = document.getElementById('resetButton');
    var messageText = document.getElementById('message');
    var isPuppyDisplayed = false;

    function preload() {
      // Load puppy images
      this.load.image('puppy1', 'images/puppy1.jpg');
      this.load.image('puppy2', 'images/puppy2.jpg');
    }

    function create() {
      // Initialize the game grid
      grid = [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ];
      
      // Add title and score
      this.add.text(200, 20, '2048', { fontSize: '48px', color: '#776e65' }).setOrigin(0.5);
      scoreText = this.add.text(200, 70, 'Score: 0', { fontSize: '24px', color: '#776e65' }).setOrigin(0.5);

      // Spawn initial tiles
      addTile();
      addTile();

      // Add input handlers
      this.input.keyboard.on('keydown', handleInput, this);
      this.input.on('pointerdown', startSwipe, this);
      this.input.on('pointerup', endSwipe, this);

      // Render the initial state
      drawGrid(this);
    }

    function update() {
      // Game loop logic if needed
    }

    function handleInput(event) {
      if (isPuppyDisplayed) return; // Prevent moves if puppy image is displayed

      switch (event.code) {
        case 'ArrowUp':
          moveTiles(0);
          break;
        case 'ArrowDown':
          moveTiles(1);
          break;
        case 'ArrowLeft':
          moveTiles(2);
          break;
        case 'ArrowRight':
          moveTiles(3);
          break;
      }
    }

    function startSwipe(pointer) {
      if (isPuppyDisplayed) return; // Prevent swipe if puppy image is displayed

      startX = pointer.x;
      startY = pointer.y;
    }

    function endSwipe(pointer) {
      if (isPuppyDisplayed) return; // Prevent swipe if puppy image is displayed

      var endX = pointer.x;
      var endY = pointer.y;
      var diffX = endX - startX;
      var diffY = endY - startY;

      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (Math.abs(diffX) > swipeThreshold) {
          if (diffX > 0) {
            moveTiles(3); // Right
          } else {
            moveTiles(2); // Left
          }
        }
      } else {
        if (Math.abs(diffY) > swipeThreshold) {
          if (diffY > 0) {
            moveTiles(1); // Down
          } else {
            moveTiles(0); // Up
          }
        }
      }
    }

    function moveTiles(direction) {
      let moved = false;

      if (direction === 0) { // Up
        for (let col = 0; col < 4; col++) {
          for (let row = 1; row < 4; row++) {
            if (grid[row][col] !== 0) {
              let targetRow = row;
              while (targetRow > 0 && grid[targetRow - 1][col] === 0) {
                grid[targetRow - 1][col] = grid[targetRow][col];
                grid[targetRow][col] = 0;
                targetRow--;
                moved = true;
              }
              if (targetRow > 0 && grid[targetRow - 1][col] === grid[targetRow][col]) {
                grid[targetRow - 1][col] *= 2;
                grid[targetRow][col] = 0;
                score += grid[targetRow - 1][col];
                moved = true;
              }
            }
          }
        }
      } else if (direction === 1) { // Down
        for (let col = 0; col < 4; col++) {
          for (let row = 2; row >= 0; row--) {
            if (grid[row][col] !== 0) {
              let targetRow = row;
              while (targetRow < 3 && grid[targetRow + 1][col] === 0) {
                grid[targetRow + 1][col] = grid[targetRow][col];
                grid[targetRow][col] = 0;
                targetRow++;
                moved = true;
              }
              if (targetRow < 3 && grid[targetRow + 1][col] === grid[targetRow][col]) {
                grid[targetRow + 1][col] *= 2;
                grid[targetRow][col] = 0;
                score += grid[targetRow + 1][col];
                moved = true;
              }
            }
          }
        }
      } else if (direction === 2) { // Left
        for (let row = 0; row < 4; row++) {
          for (let col = 1; col < 4; col++) {
            if (grid[row][col] !== 0) {
              let targetCol = col;
              while (targetCol > 0 && grid[row][targetCol - 1] === 0) {
                grid[row][targetCol - 1] = grid[row][targetCol];
                grid[row][targetCol] = 0;
                targetCol--;
                moved = true;
              }
              if (targetCol > 0 && grid[row][targetCol - 1] === grid[row][targetCol]) {
                grid[row][targetCol - 1] *= 2;
                grid[row][targetCol] = 0;
                score += grid[row][targetCol - 1];
                moved = true;
              }
            }
          }
        }
      } else if (direction === 3) { // Right
        for (let row = 0; row < 4; row++) {
          for (let col = 2; col >= 0; col--) {
            if (grid[row][col] !== 0) {
              let targetCol = col;
              while (targetCol < 3 && grid[row][targetCol + 1] === 0) {
                grid[row][targetCol + 1] = grid[row][targetCol];
                grid[row][targetCol] = 0;
                targetCol++;
                moved = true;
              }
              if (targetCol < 3 && grid[row][targetCol + 1] === grid[row][targetCol]) {
                grid[row][targetCol + 1] *= 2;
                grid[row][targetCol] = 0;
                score += grid[row][targetCol + 1];
                moved = true;
              }
            }
          }
        }
      }

      if (moved) {
        addTile();
        drawGrid(game.scene.keys.default);
        scoreText.setText('Score: ' + score);
        checkPuppyThreshold();
        checkGameOver();
        checkWinCondition();
      }
    }

    function addTile() {
      let emptyTiles = [];
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          if (grid[row][col] === 0) {
            emptyTiles.push({ row: row, col: col });
          }
        }
      }
      if (emptyTiles.length > 0) {
        let newTile = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
        grid[newTile.row][newTile.col] = Math.random() < 0.9 ? 2 : 4;
      }
    }

    function drawGrid(scene) {
      // Remove previous tile objects
      tileObjects.forEach(tile => tile.destroy());
      tileObjects = [];

      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          let value = grid[row][col];
          let x = col * tileSize;
          let y = row * tileSize + 100; // Offset for title and score
          let color = getColor(value);
          let tile = scene.add.rectangle(x + tileSize / 2, y + tileSize / 2, tileSize - 10, tileSize - 10, color).setStrokeStyle(2, 0x776e65);
          tileObjects.push(tile);
          if (value !== 0) {
            let text = scene.add.text(x + tileSize / 2, y + tileSize / 2, value, { fontSize: '32px', color: '#776e65' }).setOrigin(0.5);
            tileObjects.push(text);
          }
        }
      }
    }

    function getColor(value) {
      switch (value) {
        case 2: return 0xeee4da;
        case 4: return 0xede0c8;
        case 8: return 0xf2b179;
        case 16: return 0xf59563;
        case 32: return 0xf67c5f;
        case 64: return 0xf65e3b;
        case 128: return 0xedcf72;
        case 256: return 0xedcc61;
        case 512: return 0xedc850;
        case 1024: return 0xedc53f;
        case 2048: return 0xedc22e;
        default: return 0xcdc1b4;
      }
    }

    function checkPuppyThreshold() {
      if (currentPuppyThreshold < puppyThresholds.length && score >= puppyThresholds[currentPuppyThreshold]) {
        let puppyImageKey = currentPuppyThreshold === 0 ? 'puppy1' : 'puppy2';
        puppyImage = game.scene.keys.default.add.image(200, 250, puppyImageKey).setScale(0.5).setDepth(1); // Show puppy image
        isPuppyDisplayed = true;
        continueButton.style.display = 'block';
        continueButton.onclick = clearPuppyImage;
        currentPuppyThreshold++;
      }
    }

    function clearPuppyImage() {
      puppyImage.destroy();
      isPuppyDisplayed = false;
      continueButton.style.display = 'none';
    }

    function checkGameOver() {
      if (!canMove()) {
        messageText.textContent = 'Game Over';
        messageText.style.display = 'block';
        resetButton.style.display = 'block';
        resetButton.onclick = resetGame;
      }
    }

    function canMove() {
      // Check for empty tiles
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          if (grid[row][col] === 0) {
            return true;
          }
        }
      }
      // Check for possible merges
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          if (row < 3 && grid[row][col] === grid[row + 1][col]) {
            return true;
          }
          if (col < 3 && grid[row][col] === grid[row][col + 1]) {
            return true;
          }
        }
      }
      return false;
    }

    function checkWinCondition() {
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 4; col++) {
          if (grid[row][col] === 2048) {
            messageText.textContent = 'You Win!';
            messageText.style.display = 'block';
            resetButton.style.display = 'block';
            resetButton.onclick = resetGame;
          }
        }
      }
    }

    function resetGame() {
      // Reset game variables
      grid = [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ];
      score = 0;
      currentPuppyThreshold = 0;
      isPuppyDisplayed = false;
      drawGrid(game.scene.keys.default);
      addTile();
      addTile();
      scoreText.setText('Score: 0');
      messageText.style.display = 'none';
      continueButton.style.display = 'none';
      resetButton.style.display = 'none';
    }
  </script>
</body>
</html>
